# Конфигурационное управление

## Вариант 16
Разработать эмулятор для языка оболочки ОС. Необходимо сделать работу 
эмулятора как можно более похожей на работу в командной строке UNIX-
подобной ОС.

### Эмулятор реализован на языке Python. Оболочка реализована с помощью библиотеки tkinter.

### Доступные команды:
```
ls [путь]        – показать содержимое каталога
cd <путь>        – сменить каталог
pwd              – показать текущий путь
cat <файл>       – вывести содержимое файла
wc <файл>        – подсчитать строки, слова, символы
rev <файл>       – вывести содержимое файла наоборот
du [путь]        – показать размер файла/каталога
touch <файл>     – создать пустой файл
help             – показать список команд
exit             – выйти из эмулятора
```
## Этап 1. REPL
Цель: создать минимальный прототип. Большинство функций в нем пока 
представляют собой заглушки, но диалог с пользователем уже поддерживается.

### Требования:
1. Приложение должно быть реализовано в форме консольного интерфейса 
(CLI).
2. Приглашение к вводу должно содержать имя VFS.
3. Реализовать парсер, который корректно обрабатывает аргументы в 
кавычках.
4. Реализовать команды-заглушки, которые выводят свое имя и аргументы: ls, 
cd.
5. Реализовать команду exit.
6. Продемонстрировать работу прототипа в интерактивном режиме.
   Необходимо показать примеры работы всей реализованной
   функциональности, включая обработку ошибок.

## Этап 2. Конфигурация
Цель: сделать эмулятор настраиваемым, то есть поддержать ввод параметров 
пользователя в приложение. Организовать для этого этапа отладочный вывод всех 
заданных параметров при запуске эмулятора.

### Требования:
1. Параметры командной строки:
   – Путь к физическому расположению VFS.
   – Путь к стартовому скрипту.
2. Стартовый скрипт для выполнения команд эмулятора: останавливается при 
   первой ошибке. При выполнении скрипта на экране отображается как ввод, 
   так и вывод, имитируя диалог с пользователем.
3. Создать несколько скриптов реальной ОС, в которой выполняется эмулятор. 
   Включить в каждый скрипт вызовы эмулятора для тестирования всех 
   поддерживаемых параметров командной строки.

## Этап 3. VFS
Цель: подключить виртуальную файловую систему (VFS).

### Требования:
1. Все операции должны производиться в памяти. Запрещается распаковывать 
   или иным образом модифицировать данные VFS, за исключением 
    возможных служебных команд.
2. Источником VFS является JSON-файл. Для двоичных данных используется 
   base64 или аналогичный формат.
3. Сообщить об ошибке загрузки VFS (файл не найден, неверный формат).
4. Если путь к VFS при загрузке эмулятора не указан, то создать VFS по 
   умолчанию в памяти.
5. Создать несколько скриптов реальной ОС, в которой выполняется эмулятор. 
   Включить в каждый скрипт вызовы эмулятора для тестирования работы c 
   различными вариантами VFS (минимальный, несколько файлов, не менее 3 
   уровней файлов и папок).
6. Создать стартовый скрипт для тестирования всех реализованных на этом и 
   прошлых этапах команд. Добавить туда примеры всех режимов команд, 
   включая работу с VFS и обработку ошибок.

## Этап 4. Основные команды
Цель: поддержать команды, имитирующие работу в UNIX-подобной 
командной строке.

### Требования:
1. Необходимо реализовать логику для ls и cd.
2. Реализовать новые команды: wc, rev, du.
3. Создать стартовый скрипт для тестирования всех реализованных на этом 
   этапе команд. Добавить туда примеры всех режимов команд, включая 
   работу с VFS и обработку ошибок.

## Этап 5. Дополнительные команды
Цель: поддержать более сложные команды, изменяющие состояние VFS, при 
этом модификации должны осуществляться только в памяти.

### Требования:
1. Реализовать команды: touch.
2. По команде help выдать список команд с описанием их работы.
3. Создать стартовый скрипт для тестирования всех реализованных на этом 
   этапе команд. Добавить туда примеры всех режимов команд, включая 
   работу с VFS и обработку ошибок
